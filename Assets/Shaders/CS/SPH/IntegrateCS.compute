#pragma kernel Integrate

#include "UnityCG.cginc"

#include "Common.hlsl"
#include "../Tools.hlsl"


StructuredBuffer<Particle> _ParticleBufferRead;
RWStructuredBuffer<Particle> _ParticleBufferWrite;

StructuredBuffer<ParticleDensity> _ParticleDensityBufferRead;

RWStructuredBuffer<ParticleForce> _ParticleForceBufferRW;

AppendStructuredBuffer<uint> _ParticleAppendIndexBuffer;

void OnHandleMaxSpeed(inout Particle p)
{
	float speed = length(p.vel);
	// float rand = wang_hash01(p.UUID());
	// float maxSpeed = _MaxSpeed + lerp(-1,1,rand);
	float maxSpeed = _MaxSpeed;
	if(speed > maxSpeed && maxSpeed > 0) p.vel = normalize(p.vel) * maxSpeed;
}

#define LIMIT_MIN(space, p, axis, b)\
if(space.axis && p.pos.axis < b.axis){\
p.vel.axis = 0; p.pos.axis = b.axis;}

#define LIMIT_MAX(space, p, axis, b)\
if(space.axis && p.pos.axis > b.axis){\
p.vel.axis = 0; p.pos.axis = b.axis;}

#define INACTIVE_IF_INVALID(p, gmin, gmax)\
if(any(p.pos < gmin) || any(p.pos > gmax)) p.SetActive(false);

void OnCheckBounds(inout Particle p, float3 gmin, float3 gmax, bool3 limitSpace = true)
{
	bool3 space = limitSpace;

	LIMIT_MIN(space, p, x, gmin)
	LIMIT_MAX(space, p, x, gmax)

	LIMIT_MIN(space, p, y, gmin)
	LIMIT_MAX(space, p, y, gmax)

	LIMIT_MIN(space, p, z, gmin)
	LIMIT_MAX(space, p, z, gmax)

	INACTIVE_IF_INVALID(p, gmin, gmax)
}

[numthreads(128,1,1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(id);

    const uint p_id = id.x;
	Particle p = _ParticleBufferRead[p_id];

	if(p.IsFluid() && p.IsActive())
	{
		float3 force = _ParticleForceBufferRW[p_id].linearForce;
		float3 transferForce = _ParticleForceBufferRW[p_id].transferForce;
		float3 transferTorque = _ParticleForceBufferRW[p_id].transferTorque;

		p.vel = p.vel + _TimeStep * (force + transferForce) / _ParticleMass;

		OnHandleMaxSpeed(p);

		p.pos += _TimeStep * p.vel;
		p.w +=  _TimeStep * (transferTorque + _NU_EXT) / (_ParticleMass * _Theta);

		// p.col = _ParticleDensityBufferRead[p_id].density/ 1000;

		// if(p.pos.y < _SpaceMin.y) p.pos.y = _SpaceMax.y;
		// if(p.pos.y < _SpaceMin.y) p.SetActive(false);
	}

	if(p.IsActive() == false)
	{
		//it is important to randomly distributing particle in the whole space
		p.pos = lerp(_SpaceMin, _SpaceMax, GenerateRandomPos01(p_id));
		_ParticleAppendIndexBuffer.Append(p_id);
	}

	OnCheckBounds(p, _SpaceMin, _SpaceMax);
	// Update
	_ParticleBufferWrite[p_id] = p;

	//reset force for next frame
	// _ParticleForceBufferRW[p_id] = (ParticleForce)0;
}